---
Id: 1023
Title: "Day 23: Label Post-Processing: Partitioning Flagged vs Passed Mathematically"
Author: Sughosh P Dixit
Date: "2025-11-23"
Tags: Data Science Classification Rule-Based Indicator Functions Partitioning Priority Levels Post-Processing Thresholds
Topic: Data Science
Abstract: "Learn to view event tagging as rule-based classification. Understand indicator functions, piecewise partitions, and priority-level conditioningâ€”essential tools for mathematically partitioning events into Flagged and Passed categories."
HeaderImage: /DS-23/label_postprocessing_intro.png
isPublished: true
---

# **Day 23: Label Post-Processing: Partitioning Flagged vs Passed Mathematically** ğŸ·ï¸ğŸ“Š

<p style={{fontStyle: 'italic', color: '#666', marginTop: '1rem', textAlign: 'center'}}>See event tagging as rule-based classification. Learn to mathematically partition events using indicator functions and piecewise rules.</p>

<Lottie animation="analyticsPulse" height={240} width={340} caption="Label post-processing transforms raw predictions into actionable categories through mathematical rules and threshold-based partitioning." />

<p style={{fontStyle: 'italic', color: '#666', margin: '1rem 0 2rem', textAlign: 'center'}}>When working with scores and event classifications, we often need to partition data into distinct categories. Understanding the mathematical foundations of these partitions helps us reason about rule behavior and ensure consistency.</p>

> ğŸ’¡ **Note:** This article uses technical terms and abbreviations. For definitions, check out the [Key Terms & Glossary](/key) page.

---

## The Problem: Event Tagging as Classification ğŸ¯

**Scenario:** You have a scoring system that produces continuous scores (0-100). You need to decide:
- Which events get **Flagged** â†’ Require human review
- Which events get **Passed** â†’ Auto-approved or processed

**Challenge:** How do you mathematically define and reason about these partitions?

**Example:**
```
Raw scores: [23, 67, 45, 89, 12, 55, 78, 34]
Threshold: 50

Flagged (score â‰¥ 50): [67, 89, 55, 78] â†’ 4 events (50%)
Passed (score < 50):  [23, 45, 12, 34] â†’ 4 events (50%)
```

**The question:** How do we formalize this mathematically? ğŸ¤”

---

## Indicator Functions: The Building Blocks ğŸ§±

### What is an Indicator Function?

An **indicator function** (also called a characteristic function) is a function that returns 1 if a condition is true, and 0 otherwise.

**Notation:**
```
ğŸ™{condition} = {
    1, if condition is true
    0, if condition is false
}
```

**Also written as:**
- `I(condition)`
- `1_A` (indicator of set A)
- `[condition]` (Iverson bracket)

### Examples of Indicator Functions

**Example 1: Simple Threshold**
```
ğŸ™{x â‰¥ 50} = {
    1, if x â‰¥ 50
    0, if x < 50
}

For x = 67: ğŸ™{67 â‰¥ 50} = 1 âœ“
For x = 23: ğŸ™{23 â‰¥ 50} = 0 âœ—
```

**Example 2: Range Check**
```
ğŸ™{30 â‰¤ x < 70} = {
    1, if 30 â‰¤ x < 70
    0, otherwise
}

For x = 45: ğŸ™{30 â‰¤ 45 < 70} = 1 âœ“
For x = 80: ğŸ™{30 â‰¤ 80 < 70} = 0 âœ—
```

**Visual Example:**

<img src="/DS-23/indicator_function.png" alt="Indicator Function Visualization" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

<Lottie animation="robustWorkflow" height={220} width={320} caption="Indicator functions transform continuous values into binary decisions, forming the foundation of threshold-based classification." />

---

## Indicator Functions for Inequalities ğŸ“

### Common Inequality Patterns

**Greater Than or Equal:**
```
ğŸ™{x â‰¥ t} = {
    1, if x â‰¥ t
    0, if x < t
}
```

**Less Than:**
```
ğŸ™{x < t} = {
    1, if x < t
    0, if x â‰¥ t
}
```

**Complement Property:**
```
ğŸ™{x < t} = 1 - ğŸ™{x â‰¥ t}
```

**Double-Sided (Range):**
```
ğŸ™{a â‰¤ x < b} = ğŸ™{x â‰¥ a} Â· ğŸ™{x < b}
```

### Flagged vs Passed with Indicator Functions

**Definition:**
```
Flagged(x) = ğŸ™{x â‰¥ threshold}
Passed(x) = ğŸ™{x < threshold} = 1 - Flagged(x)
```

**Key Property: Partition**
```
Flagged(x) + Passed(x) = 1  (for all x)
```

This means every event is either Flagged or Passedâ€”never both, never neither!

**Visual Example:**

<img src="/DS-23/atl_btl_indicator.png" alt="Flagged vs Passed Indicator Functions" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

---

## Piecewise Partitions: Multiple Categories ğŸ“Š

### What is a Piecewise Partition?

A **piecewise partition** divides the domain into multiple non-overlapping regions, each handled by a different rule.

**Example: Priority Levels**
```
Priority Level(x) = {
    "Low",      if x < 30
    "Medium",   if 30 â‰¤ x < 70
    "High",     if x â‰¥ 70
}
```

### Mathematical Representation

Using indicator functions:
```
Low(x)    = ğŸ™{x < 30}
Medium(x) = ğŸ™{30 â‰¤ x < 70}
High(x)   = ğŸ™{x â‰¥ 70}
```

**Partition Property:**
```
Low(x) + Medium(x) + High(x) = 1  (for all x)
```

### General Form

For thresholds `tâ‚ < tâ‚‚ < ... < tâ‚™`:

```
Regionâ‚€(x) = ğŸ™{x < tâ‚}
Regionâ‚(x) = ğŸ™{tâ‚ â‰¤ x < tâ‚‚}
Regionâ‚‚(x) = ğŸ™{tâ‚‚ â‰¤ x < tâ‚ƒ}
...
Regionâ‚™(x) = ğŸ™{x â‰¥ tâ‚™}
```

**Visual Example:**

<img src="/DS-23/piecewise_partition.png" alt="Piecewise Partition" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

<Lottie animation="breakdownFortress" height={220} width={320} caption="Piecewise partitions divide the score space into distinct regions, each with its own handling logic." />

---

## Priority-Level Conditioning ğŸ²

### What is Priority-Level Conditioning?

**Priority-level conditioning** means applying different rules based on the priority level of an event.

**Example:**
```
Flag_rule(x, priority) = {
    ğŸ™{x â‰¥ 30},  if priority = "Low"     (lower threshold for low priority)
    ğŸ™{x â‰¥ 50},  if priority = "Medium"  (standard threshold)
    ğŸ™{x â‰¥ 70},  if priority = "High"    (higher threshold for high priority)
}
```

### Mathematical Formulation

Let `P(x)` be the priority level function. The conditioned Flag rule is:

```
Flagged(x) = ğŸ™{P(x) = "Low"} Â· ğŸ™{x â‰¥ 30}
           + ğŸ™{P(x) = "Medium"} Â· ğŸ™{x â‰¥ 50}
           + ğŸ™{P(x) = "High"} Â· ğŸ™{x â‰¥ 70}
```

**Interpretation:**
- Low-priority events: Flagged if score â‰¥ 30
- Medium-priority events: Flagged if score â‰¥ 50
- High-priority events: Flagged if score â‰¥ 70

### Why Different Thresholds?

**Rationale:**
- **Low-priority segments:** More conservative, flag more events
- **High-priority segments:** More aggressive, focus on highest scores
- **Resource allocation:** Direct review resources where they matter most

**Visual Example:**

<img src="/DS-23/risk_level_conditioning.png" alt="Priority-Level Conditioning" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

---

## Real-World Application: partition_events_by_thresholds ğŸ”§

### Purpose

The `partition_events_by_thresholds` function applies tuned rules and updates tags for each event.

**Use Cases:**
- Classify events into Flagged/Passed categories
- Apply priority-level specific thresholds
- Update event labels based on post-processing rules
- Track before/after tag distributions

### Function Concept

```python
def partition_events_by_thresholds(events, thresholds, priority_levels):
    """
    Partition events into Flagged/Passed based on thresholds and priority levels.
    
    Parameters:
    - events: List of event dictionaries with 'score' and 'priority_level'
    - thresholds: Dict mapping priority levels to thresholds
    - priority_levels: List of priority levels to consider
    
    Returns:
    - events: Updated with 'tag' field (Flagged or Passed)
    - stats: Before/after class proportions per priority level
    """
    for event in events:
        priority = event['priority_level']
        score = event['score']
        threshold = thresholds.get(priority, 50)  # Default threshold
        
        # Apply indicator function
        if score >= threshold:
            event['tag'] = 'Flagged'
        else:
            event['tag'] = 'Passed'
    
    return events, compute_stats(events, priority_levels)
```

### Example Application

**Input:**
```python
events = [
    {'id': 1, 'score': 45, 'priority_level': 'Low'},
    {'id': 2, 'score': 55, 'priority_level': 'Medium'},
    {'id': 3, 'score': 65, 'priority_level': 'High'},
    {'id': 4, 'score': 35, 'priority_level': 'Low'},
    {'id': 5, 'score': 75, 'priority_level': 'High'},
]

thresholds = {
    'Low': 30,
    'Medium': 50,
    'High': 70
}
```

**Output:**
```python
# Event 1: score=45, priority=Low, threshold=30 â†’ 45 â‰¥ 30 â†’ Flagged
# Event 2: score=55, priority=Medium, threshold=50 â†’ 55 â‰¥ 50 â†’ Flagged
# Event 3: score=65, priority=High, threshold=70 â†’ 65 < 70 â†’ Passed
# Event 4: score=35, priority=Low, threshold=30 â†’ 35 â‰¥ 30 â†’ Flagged
# Event 5: score=75, priority=High, threshold=70 â†’ 75 â‰¥ 70 â†’ Flagged

# Results:
# Flagged: [Event 1, Event 2, Event 4, Event 5] â†’ 4 events (80%)
# Passed: [Event 3] â†’ 1 event (20%)
```

**Visual Example:**

<img src="/DS-23/partition_function.png" alt="Partition Function Application" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

---

## Before/After Class Proportions ğŸ“ˆ

### Visualizing the Impact

When you apply post-processing rules, it's crucial to visualize the **before/after** class proportions.

**Example Scenario:**

**Before (Uniform Threshold = 50):**
```
Priority Level  Total  Flagged  Passed  Flagged%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Low             1000     400     600      40%
Medium          2000     900    1100      45%
High            1500     800     700      53%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total           4500    2100    2400      47%
```

**After (Priority-Conditioned Thresholds):**
```
Thresholds: Low=30, Medium=50, High=70

Priority Level  Total  Flagged  Passed  Flagged%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Low             1000     700     300      70%  â†‘ More review
Medium          2000     900    1100      45%  = Same
High            1500     500    1000      33%  â†“ Less review
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total           4500    2100    2400      47%  = Same total!
```

**Key Insight:** Priority-level conditioning redistributes review load without changing total volume!

**Visual Example:**

<img src="/DS-23/before_after_proportions.png" alt="Before/After Class Proportions" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

<Lottie animation="classicalVsRobust" height={220} width={320} caption="Comparing before/after distributions helps you understand the impact of rule changes on each priority segment." />

---

## Exercise: Monotonicity of Conjunctive Clauses ğŸ“

### The Problem

**Theorem:** Adding a conjunctive clause can only **shrink** the Flagged set.

**Claim:** If we define:
```
Flagâ‚(x) = ğŸ™{x â‰¥ tâ‚}
Flagâ‚‚(x) = ğŸ™{x â‰¥ tâ‚} Â· ğŸ™{x â‰¥ tâ‚‚}  (where tâ‚‚ > tâ‚)
```

Then: `Flagâ‚‚(x) â‰¤ Flagâ‚(x)` for all x.

**Prove this monotonicity property.**

### Solution

**Step 1: Analyze Flagâ‚**
```
Flagâ‚(x) = ğŸ™{x â‰¥ tâ‚} = {
    1, if x â‰¥ tâ‚
    0, if x < tâ‚
}
```

**Step 2: Analyze Flagâ‚‚**
```
Flagâ‚‚(x) = ğŸ™{x â‰¥ tâ‚} Â· ğŸ™{x â‰¥ tâ‚‚}
```

Since tâ‚‚ > tâ‚, the condition `x â‰¥ tâ‚‚` implies `x â‰¥ tâ‚`.

Therefore:
```
Flagâ‚‚(x) = {
    1, if x â‰¥ tâ‚‚ (which implies x â‰¥ tâ‚)
    0, otherwise
}
```

**Step 3: Compare**

Case analysis for all x:

| Case | x < tâ‚ | tâ‚ â‰¤ x < tâ‚‚ | x â‰¥ tâ‚‚ |
|------|--------|-------------|--------|
| Flagâ‚ | 0 | 1 | 1 |
| Flagâ‚‚ | 0 | 0 | 1 |
| Flagâ‚‚ â‰¤ Flagâ‚? | âœ“ (0 â‰¤ 0) | âœ“ (0 â‰¤ 1) | âœ“ (1 â‰¤ 1) |

**Step 4: Conclusion**

For all x: `Flagâ‚‚(x) â‰¤ Flagâ‚(x)` âœ“

**Interpretation:** Adding the extra condition `x â‰¥ tâ‚‚` (where tâ‚‚ > tâ‚) can only make it **harder** to be Flagged, never easier. This is the **monotonicity property** of conjunctive clauses.

### General Principle

**Monotonicity of AND:**
```
If C = A âˆ§ B, then:
- C can only be true when BOTH A and B are true
- C âŠ† A and C âŠ† B
- |C| â‰¤ min(|A|, |B|)
```

**Practical Implication:**
- Adding more conditions to a rule can only **reduce** the set of matching events
- Never **increase** it
- This is useful for understanding rule refinement

**Visual Example:**

<img src="/DS-23/monotonicity_proof.png" alt="Monotonicity Proof" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

---

## Practical Applications ğŸ”§

### 1. Rule Refinement

**Scenario:** Current Flagged rule catches too many false positives.

**Solution:** Add conjunctive clauses to narrow down:
```
Before: Flagged = ğŸ™{score â‰¥ 50}
After:  Flagged = ğŸ™{score â‰¥ 50} Â· ğŸ™{amount â‰¥ 1000}
```

**Guaranteed:** New Flagged âŠ† Old Flagged (monotonicity)

### 2. A/B Testing Rules

**Scenario:** Testing a new threshold.

**Approach:**
1. Define Flag_control and Flag_treatment
2. Use indicator functions to track differences
3. Measure `|Flag_control âŠ• Flag_treatment|` (symmetric difference)

### 3. Threshold Calibration

**Scenario:** Adjusting thresholds per priority level.

**Method:**
1. Start with uniform threshold
2. Apply priority-level conditioning
3. Monitor before/after proportions
4. Iterate until balanced

---

## Best Practices for Label Post-Processing âœ…

### 1. Document Your Rules Mathematically

Write rules as indicator functions to:
- Ensure clarity
- Enable formal reasoning
- Detect logical errors

### 2. Verify Partition Properties

Always check that:
```
âˆ‘ Category_i(x) = 1 for all x
```

Every event belongs to exactly one category.

### 3. Track Before/After Proportions

Monitor class distributions:
- Per priority level
- Per segment
- Over time

### 4. Understand Monotonicity

When adding conditions:
- Conjunctive (AND): Shrinks the set
- Disjunctive (OR): Expands the set

### 5. Test Edge Cases

Check behavior at:
- Exact threshold values
- Boundary conditions
- Missing data scenarios

### 6. Version Control Your Rules

Track rule changes:
- What changed
- When it changed
- Why it changed
- Impact on proportions

---

## Summary Table ğŸ“‹

<table>
<thead>
<tr>
<th>Concept</th>
<th>Notation</th>
<th>Description</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Indicator Function</strong></td>
<td><code>ğŸ™&#123;condition&#125;</code></td>
<td>Returns 1 if true, 0 if false</td>
<td>Binary classification</td>
</tr>
<tr>
<td><strong>Flagged Indicator</strong></td>
<td><code>ğŸ™&#123;x â‰¥ t&#125;</code></td>
<td>Above threshold check</td>
<td>Review flagging</td>
</tr>
<tr>
<td><strong>Passed Indicator</strong></td>
<td><code>1 - ğŸ™&#123;x â‰¥ t&#125;</code></td>
<td>Below threshold (complement)</td>
<td>Auto-processing</td>
</tr>
<tr>
<td><strong>Piecewise Partition</strong></td>
<td>âˆ‘ Region_i = 1</td>
<td>Non-overlapping regions</td>
<td>Multi-category classification</td>
</tr>
<tr>
<td><strong>Priority Conditioning</strong></td>
<td>Flagged(x, priority)</td>
<td>Different thresholds per priority</td>
<td>Segment-specific rules</td>
</tr>
<tr>
<td><strong>Monotonicity</strong></td>
<td>A âˆ§ B âŠ† A</td>
<td>AND shrinks sets</td>
<td>Rule refinement</td>
</tr>
</tbody>
</table>

---

## Final Thoughts ğŸŒŸ

Label post-processing is fundamentally about applying mathematical rules to partition events into categories. By formalizing these rules with indicator functions, we gain:

- **Clarity:** Precise definitions that eliminate ambiguity
- **Reasoning:** Ability to prove properties like monotonicity
- **Consistency:** Guaranteed partitions where every event has exactly one category
- **Insight:** Before/after comparisons that reveal rule impact

**Key Takeaways:**

âœ… **Indicator functions** are the building blocks of rule-based classification
âœ… **Piecewise partitions** divide the score space into non-overlapping regions
âœ… **Priority-level conditioning** allows segment-specific thresholds
âœ… **partition_events_by_thresholds** applies tuned rules and updates tags
âœ… **Before/after proportions** reveal the impact of rule changes
âœ… **Conjunctive clauses** can only shrink the Flagged set (monotonicity)

**Think mathematically about your rules!** ğŸ§®ğŸ¯

**Tomorrow's Preview:** Day 24 - Risk Segmentation: Priority Tiers as Priors and Costs âš–ï¸ğŸ“Š

---


