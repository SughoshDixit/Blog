---
Id: 1023
Title: "Day 23: Label Post-Processing: Partitioning ATL vs BTL Mathematically"
Author: Sughosh P Dixit
Date: "2025-11-23"
Tags: Data Science Classification Rule-Based Indicator Functions Partitioning Risk Levels ATL BTL Post-Processing
Topic: Data Science
Abstract: "Learn to view event tagging as rule-based classification. Understand indicator functions, piecewise partitions, and risk-level conditioningâ€”essential tools for mathematically partitioning events into Above The Line (ATL) and Below The Line (BTL) categories."
HeaderImage: /DS-23/label_postprocessing_intro.png
isPublished: true
---

# **Day 23: Label Post-Processing: Partitioning ATL vs BTL Mathematically** ğŸ·ï¸ğŸ“Š

<p style={{fontStyle: 'italic', color: '#666', marginTop: '1rem', textAlign: 'center'}}>See event tagging as rule-based classification. Learn to mathematically partition events using indicator functions and piecewise rules.</p>

<Lottie animation="analyticsPulse" height={240} width={340} caption="Label post-processing transforms raw predictions into actionable categories through mathematical rules and threshold-based partitioning." />

<p style={{fontStyle: 'italic', color: '#666', margin: '1rem 0 2rem', textAlign: 'center'}}>When working with risk scores and event classifications, we often need to partition data into distinct categories. Understanding the mathematical foundations of these partitions helps us reason about rule behavior and ensure consistency.</p>

> ğŸ’¡ **Note:** This article uses technical terms and abbreviations. For definitions, check out the [Key Terms & Glossary](/key) page.

---

## The Problem: Event Tagging as Classification ğŸ¯

**Scenario:** You have a risk scoring system that produces continuous scores (0-100). You need to decide:
- Which events go **Above The Line (ATL)** â†’ Require human review
- Which events stay **Below The Line (BTL)** â†’ Auto-approved or declined

**Challenge:** How do you mathematically define and reason about these partitions?

**Example:**
```
Raw scores: [23, 67, 45, 89, 12, 55, 78, 34]
Threshold: 50

ATL (score â‰¥ 50): [67, 89, 55, 78] â†’ 4 events (50%)
BTL (score < 50):  [23, 45, 12, 34] â†’ 4 events (50%)
```

**The question:** How do we formalize this mathematically? ğŸ¤”

---

## Indicator Functions: The Building Blocks ğŸ§±

### What is an Indicator Function?

An **indicator function** (also called a characteristic function) is a function that returns 1 if a condition is true, and 0 otherwise.

**Notation:**
```
ğŸ™{condition} = {
    1, if condition is true
    0, if condition is false
}
```

**Also written as:**
- `I(condition)`
- `1_A` (indicator of set A)
- `[condition]` (Iverson bracket)

### Examples of Indicator Functions

**Example 1: Simple Threshold**
```
ğŸ™{x â‰¥ 50} = {
    1, if x â‰¥ 50
    0, if x < 50
}

For x = 67: ğŸ™{67 â‰¥ 50} = 1 âœ“
For x = 23: ğŸ™{23 â‰¥ 50} = 0 âœ—
```

**Example 2: Range Check**
```
ğŸ™{30 â‰¤ x < 70} = {
    1, if 30 â‰¤ x < 70
    0, otherwise
}

For x = 45: ğŸ™{30 â‰¤ 45 < 70} = 1 âœ“
For x = 80: ğŸ™{30 â‰¤ 80 < 70} = 0 âœ—
```

**Visual Example:**

<img src="/DS-23/indicator_function.png" alt="Indicator Function Visualization" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

<Lottie animation="robustWorkflow" height={220} width={320} caption="Indicator functions transform continuous values into binary decisions, forming the foundation of threshold-based classification." />

---

## Indicator Functions for Inequalities ğŸ“

### Common Inequality Patterns

**Greater Than or Equal:**
```
ğŸ™{x â‰¥ t} = {
    1, if x â‰¥ t
    0, if x < t
}
```

**Less Than:**
```
ğŸ™{x < t} = {
    1, if x < t
    0, if x â‰¥ t
}
```

**Complement Property:**
```
ğŸ™{x < t} = 1 - ğŸ™{x â‰¥ t}
```

**Double-Sided (Range):**
```
ğŸ™{a â‰¤ x < b} = ğŸ™{x â‰¥ a} Â· ğŸ™{x < b}
```

### ATL vs BTL with Indicator Functions

**Definition:**
```
ATL(x) = ğŸ™{x â‰¥ threshold}
BTL(x) = ğŸ™{x < threshold} = 1 - ATL(x)
```

**Key Property: Partition**
```
ATL(x) + BTL(x) = 1  (for all x)
```

This means every event is either ATL or BTLâ€”never both, never neither!

**Visual Example:**

<img src="/DS-23/atl_btl_indicator.png" alt="ATL vs BTL Indicator Functions" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

---

## Piecewise Partitions: Multiple Categories ğŸ“Š

### What is a Piecewise Partition?

A **piecewise partition** divides the domain into multiple non-overlapping regions, each handled by a different rule.

**Example: Risk Levels**
```
Risk Level(x) = {
    "Low",      if x < 30
    "Medium",   if 30 â‰¤ x < 70
    "High",     if x â‰¥ 70
}
```

### Mathematical Representation

Using indicator functions:
```
Low(x)    = ğŸ™{x < 30}
Medium(x) = ğŸ™{30 â‰¤ x < 70}
High(x)   = ğŸ™{x â‰¥ 70}
```

**Partition Property:**
```
Low(x) + Medium(x) + High(x) = 1  (for all x)
```

### General Form

For thresholds `tâ‚ < tâ‚‚ < ... < tâ‚™`:

```
Regionâ‚€(x) = ğŸ™{x < tâ‚}
Regionâ‚(x) = ğŸ™{tâ‚ â‰¤ x < tâ‚‚}
Regionâ‚‚(x) = ğŸ™{tâ‚‚ â‰¤ x < tâ‚ƒ}
...
Regionâ‚™(x) = ğŸ™{x â‰¥ tâ‚™}
```

**Visual Example:**

<img src="/DS-23/piecewise_partition.png" alt="Piecewise Partition" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

<Lottie animation="breakdownFortress" height={220} width={320} caption="Piecewise partitions divide the score space into distinct regions, each with its own handling logic." />

---

## Risk-Level Conditioning ğŸ²

### What is Risk-Level Conditioning?

**Risk-level conditioning** means applying different rules based on the risk level of an event.

**Example:**
```
ATL_rule(x, risk) = {
    ğŸ™{x â‰¥ 30},  if risk = "Low"     (lower threshold for low risk)
    ğŸ™{x â‰¥ 50},  if risk = "Medium"  (standard threshold)
    ğŸ™{x â‰¥ 70},  if risk = "High"    (higher threshold for high risk)
}
```

### Mathematical Formulation

Let `R(x)` be the risk level function. The conditioned ATL rule is:

```
ATL(x) = ğŸ™{R(x) = "Low"} Â· ğŸ™{x â‰¥ 30}
       + ğŸ™{R(x) = "Medium"} Â· ğŸ™{x â‰¥ 50}
       + ğŸ™{R(x) = "High"} Â· ğŸ™{x â‰¥ 70}
```

**Interpretation:**
- Low-risk events: ATL if score â‰¥ 30
- Medium-risk events: ATL if score â‰¥ 50
- High-risk events: ATL if score â‰¥ 70

### Why Different Thresholds?

**Rationale:**
- **Low-risk segments:** More conservative, flag more events
- **High-risk segments:** More aggressive, focus on highest scores
- **Resource allocation:** Direct review resources where they matter most

**Visual Example:**

<img src="/DS-23/risk_level_conditioning.png" alt="Risk-Level Conditioning" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

---

## Real-World Application: partition_events_by_thresholds ğŸ”§

### Purpose

The `partition_events_by_thresholds` function applies tuned rules and updates tags for each event.

**Use Cases:**
- Classify transactions into ATL/BTL categories
- Apply risk-level specific thresholds
- Update event labels based on post-processing rules
- Track before/after tag distributions

### Function Concept

```python
def partition_events_by_thresholds(events, thresholds, risk_levels):
    """
    Partition events into ATL/BTL based on thresholds and risk levels.
    
    Parameters:
    - events: List of event dictionaries with 'score' and 'risk_level'
    - thresholds: Dict mapping risk levels to thresholds
    - risk_levels: List of risk levels to consider
    
    Returns:
    - events: Updated with 'tag' field (ATL or BTL)
    - stats: Before/after class proportions per risk level
    """
    for event in events:
        risk = event['risk_level']
        score = event['score']
        threshold = thresholds.get(risk, 50)  # Default threshold
        
        # Apply indicator function
        if score >= threshold:
            event['tag'] = 'ATL'
        else:
            event['tag'] = 'BTL'
    
    return events, compute_stats(events, risk_levels)
```

### Example Application

**Input:**
```python
events = [
    {'id': 1, 'score': 45, 'risk_level': 'Low'},
    {'id': 2, 'score': 55, 'risk_level': 'Medium'},
    {'id': 3, 'score': 65, 'risk_level': 'High'},
    {'id': 4, 'score': 35, 'risk_level': 'Low'},
    {'id': 5, 'score': 75, 'risk_level': 'High'},
]

thresholds = {
    'Low': 30,
    'Medium': 50,
    'High': 70
}
```

**Output:**
```python
# Event 1: score=45, risk=Low, threshold=30 â†’ 45 â‰¥ 30 â†’ ATL
# Event 2: score=55, risk=Medium, threshold=50 â†’ 55 â‰¥ 50 â†’ ATL
# Event 3: score=65, risk=High, threshold=70 â†’ 65 < 70 â†’ BTL
# Event 4: score=35, risk=Low, threshold=30 â†’ 35 â‰¥ 30 â†’ ATL
# Event 5: score=75, risk=High, threshold=70 â†’ 75 â‰¥ 70 â†’ ATL

# Results:
# ATL: [Event 1, Event 2, Event 4, Event 5] â†’ 4 events (80%)
# BTL: [Event 3] â†’ 1 event (20%)
```

**Visual Example:**

<img src="/DS-23/partition_function.png" alt="Partition Function Application" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

---

## Before/After Class Proportions ğŸ“ˆ

### Visualizing the Impact

When you apply post-processing rules, it's crucial to visualize the **before/after** class proportions.

**Example Scenario:**

**Before (Uniform Threshold = 50):**
```
Risk Level    Total    ATL    BTL    ATL%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Low           1000     400    600    40%
Medium        2000     900   1100    45%
High          1500     800    700    53%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total         4500    2100   2400    47%
```

**After (Risk-Conditioned Thresholds):**
```
Thresholds: Low=30, Medium=50, High=70

Risk Level    Total    ATL    BTL    ATL%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Low           1000     700    300    70%  â†‘ More review
Medium        2000     900   1100    45%  = Same
High          1500     500   1000    33%  â†“ Less review
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total         4500    2100   2400    47%  = Same total!
```

**Key Insight:** Risk-level conditioning redistributes review load without changing total volume!

**Visual Example:**

<img src="/DS-23/before_after_proportions.png" alt="Before/After Class Proportions" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

<Lottie animation="classicalVsRobust" height={220} width={320} caption="Comparing before/after distributions helps you understand the impact of rule changes on each risk segment." />

---

## Exercise: Monotonicity of Conjunctive Clauses ğŸ“

### The Problem

**Theorem:** Adding a conjunctive clause can only **shrink** ATL.

**Claim:** If we define:
```
ATLâ‚(x) = ğŸ™{x â‰¥ tâ‚}
ATLâ‚‚(x) = ğŸ™{x â‰¥ tâ‚} Â· ğŸ™{x â‰¥ tâ‚‚}  (where tâ‚‚ > tâ‚)
```

Then: `ATLâ‚‚(x) â‰¤ ATLâ‚(x)` for all x.

**Prove this monotonicity property.**

### Solution

**Step 1: Analyze ATLâ‚**
```
ATLâ‚(x) = ğŸ™{x â‰¥ tâ‚} = {
    1, if x â‰¥ tâ‚
    0, if x < tâ‚
}
```

**Step 2: Analyze ATLâ‚‚**
```
ATLâ‚‚(x) = ğŸ™{x â‰¥ tâ‚} Â· ğŸ™{x â‰¥ tâ‚‚}
```

Since tâ‚‚ > tâ‚, the condition `x â‰¥ tâ‚‚` implies `x â‰¥ tâ‚`.

Therefore:
```
ATLâ‚‚(x) = {
    1, if x â‰¥ tâ‚‚ (which implies x â‰¥ tâ‚)
    0, otherwise
}
```

**Step 3: Compare**

Case analysis for all x:

| Case | x < tâ‚ | tâ‚ â‰¤ x < tâ‚‚ | x â‰¥ tâ‚‚ |
|------|--------|-------------|--------|
| ATLâ‚ | 0 | 1 | 1 |
| ATLâ‚‚ | 0 | 0 | 1 |
| ATLâ‚‚ â‰¤ ATLâ‚? | âœ“ (0 â‰¤ 0) | âœ“ (0 â‰¤ 1) | âœ“ (1 â‰¤ 1) |

**Step 4: Conclusion**

For all x: `ATLâ‚‚(x) â‰¤ ATLâ‚(x)` âœ“

**Interpretation:** Adding the extra condition `x â‰¥ tâ‚‚` (where tâ‚‚ > tâ‚) can only make it **harder** to be ATL, never easier. This is the **monotonicity property** of conjunctive clauses.

### General Principle

**Monotonicity of AND:**
```
If C = A âˆ§ B, then:
- C can only be true when BOTH A and B are true
- C âŠ† A and C âŠ† B
- |C| â‰¤ min(|A|, |B|)
```

**Practical Implication:**
- Adding more conditions to a rule can only **reduce** the set of matching events
- Never **increase** it
- This is useful for understanding rule refinement

**Visual Example:**

<img src="/DS-23/monotonicity_proof.png" alt="Monotonicity Proof" style={{maxWidth: '100%', height: 'auto', display: 'block', margin: '1.5rem auto', borderRadius: '8px'}} />

---

## Practical Applications ğŸ”§

### 1. Rule Refinement

**Scenario:** Current ATL rule catches too many false positives.

**Solution:** Add conjunctive clauses to narrow down:
```
Before: ATL = ğŸ™{score â‰¥ 50}
After:  ATL = ğŸ™{score â‰¥ 50} Â· ğŸ™{amount â‰¥ 1000}
```

**Guaranteed:** New ATL âŠ† Old ATL (monotonicity)

### 2. A/B Testing Rules

**Scenario:** Testing a new threshold.

**Approach:**
1. Define ATL_control and ATL_treatment
2. Use indicator functions to track differences
3. Measure `|ATL_control âŠ• ATL_treatment|` (symmetric difference)

### 3. Threshold Calibration

**Scenario:** Adjusting thresholds per risk level.

**Method:**
1. Start with uniform threshold
2. Apply risk-level conditioning
3. Monitor before/after proportions
4. Iterate until balanced

---

## Best Practices for Label Post-Processing âœ…

### 1. Document Your Rules Mathematically

Write rules as indicator functions to:
- Ensure clarity
- Enable formal reasoning
- Detect logical errors

### 2. Verify Partition Properties

Always check that:
```
âˆ‘ Category_i(x) = 1 for all x
```

Every event belongs to exactly one category.

### 3. Track Before/After Proportions

Monitor class distributions:
- Per risk level
- Per segment
- Over time

### 4. Understand Monotonicity

When adding conditions:
- Conjunctive (AND): Shrinks the set
- Disjunctive (OR): Expands the set

### 5. Test Edge Cases

Check behavior at:
- Exact threshold values
- Boundary conditions
- Missing data scenarios

### 6. Version Control Your Rules

Track rule changes:
- What changed
- When it changed
- Why it changed
- Impact on proportions

---

## Summary Table ğŸ“‹

<table>
<thead>
<tr>
<th>Concept</th>
<th>Notation</th>
<th>Description</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Indicator Function</strong></td>
<td>ğŸ™{condition}</td>
<td>Returns 1 if true, 0 if false</td>
<td>Binary classification</td>
</tr>
<tr>
<td><strong>ATL Indicator</strong></td>
<td>ğŸ™{x â‰¥ t}</td>
<td>Above The Line check</td>
<td>Review flagging</td>
</tr>
<tr>
<td><strong>BTL Indicator</strong></td>
<td>1 - ğŸ™{x â‰¥ t}</td>
<td>Below The Line (complement)</td>
<td>Auto-processing</td>
</tr>
<tr>
<td><strong>Piecewise Partition</strong></td>
<td>âˆ‘ Region_i = 1</td>
<td>Non-overlapping regions</td>
<td>Multi-category classification</td>
</tr>
<tr>
<td><strong>Risk Conditioning</strong></td>
<td>ATL(x, risk)</td>
<td>Different thresholds per risk</td>
<td>Segment-specific rules</td>
</tr>
<tr>
<td><strong>Monotonicity</strong></td>
<td>A âˆ§ B âŠ† A</td>
<td>AND shrinks sets</td>
<td>Rule refinement</td>
</tr>
</tbody>
</table>

---

## Final Thoughts ğŸŒŸ

Label post-processing is fundamentally about applying mathematical rules to partition events into categories. By formalizing these rules with indicator functions, we gain:

- **Clarity:** Precise definitions that eliminate ambiguity
- **Reasoning:** Ability to prove properties like monotonicity
- **Consistency:** Guaranteed partitions where every event has exactly one category
- **Insight:** Before/after comparisons that reveal rule impact

**Key Takeaways:**

âœ… **Indicator functions** are the building blocks of rule-based classification
âœ… **Piecewise partitions** divide the score space into non-overlapping regions
âœ… **Risk-level conditioning** allows segment-specific thresholds
âœ… **partition_events_by_thresholds** applies tuned rules and updates tags
âœ… **Before/after proportions** reveal the impact of rule changes
âœ… **Conjunctive clauses** can only shrink ATL (monotonicity)

**Think mathematically about your rules!** ğŸ§®ğŸ¯

**Tomorrow's Preview:** Day 24 - Coming soon! ğŸ“ŠğŸ¯

---


