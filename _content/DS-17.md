---
Id: 1017
Title: "Day 17 â€” Robust Ratios and Division by Zero"
Author: Sughosh P Dixit
Date: "2025-11-17"
Tags: Data Science Robust Statistics Ratios Division by Zero MAD Stability Numerical Methods
Topic: Data Science
Abstract: "Ratios are powerful but dangerous â€” division by values near zero can make them explode! This post shows how to design stable ratio features, guard against tiny denominators, and choose a principled epsilon using robust measures like the Median Absolute Deviation (MAD)."
HeaderImage: /DS-17/robust_ratios.png
isPublished: true
---

# **Day 17 â€” Robust Ratios and Division by Zero** âš–ï¸ğŸ§®

<p style={{fontStyle: 'italic', color: '#666', marginTop: '1rem', textAlign: 'center'}}>Making ratios behave, even when denominators misbehave!</p>

<Lottie animation="analyticsPulse" height={240} width={340} caption="Robust ratios protect your calculations from division by zero and near-zero denominators, ensuring stable and reliable computations." />

<p style={{fontStyle: 'italic', color: '#666', margin: '1rem 0 2rem', textAlign: 'center'}}>Ratios are powerful but dangerousâ€”division by values near zero can make them explode! Learn how to design stable ratio features, guard against tiny denominators, and choose a principled epsilon using robust measures.</p>

> ğŸ’¡ **Note:** This article uses technical terms and abbreviations. For definitions, check out the [Key Terms & Glossary](/key) page.

---

## The Ratio Problem ğŸ’¥

Ratios are the bread and butter of data science:

**Common examples:**

- Conversion rate = clicks / views
- Efficiency = output / cost
- Growth rate = (current - past) / past
- Risk score = amount / avg_balance

But these simple formulas hide a sneaky trapâ€”what happens when the denominator is 0 or nearly 0?

**The problem:**

<table>
<thead>
<tr>
<th>Example</th>
<th>Computation</th>
<th>Result</th>
<th>Issue</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>5 / 0</td>
<td>âˆ</td>
<td>Infinity | Division by zero error ğŸš«</td>
</tr>
<tr>
<td></td>
<td>5 / 0.00001</td>
<td>500,000</td>
<td>Huge number | Explodes in scale ğŸ’¥</td>
</tr>
<tr>
<td>ğŸ’¥</td>
<td>0 / 0</td>
<td>NaN</td>
<td>Undefined | Not a number ğŸ˜µ</td>
</tr>
</tbody>
</table>


**Real-world impact:**

```
User with $0 balance â†’ risk_score = amount / 0 â†’ CRASH! ğŸ’¥
```

Your models break in production, your dashboards show infinity, and your stakeholders lose trust.

**The question:** How do we make ratios safe and stable? ğŸ¯

---

## What is a Robust Ratio? ğŸ›¡ï¸

**Definition:** A ratio that handles edge cases gracefully without exploding or crashing

**Key principles:**

- **Guard the denominator:** Never divide by zero or near-zero values
- **Use principled epsilon:** Choose stabilization constant based on data scale
- **Maintain continuity:** Smooth transitions, not sudden jumps
- **Log and monitor:** Track when guards are triggered

**Visual intuition:**

```
Unsafe ratio:     Safe ratio:
    â†‘                  â†‘
 | |
 |    âˆ |    â”€â”€â”€â”€â”€â”€â”€â”€ (clipped)
 |   / |   /
 |  / |  /
 | / | /
 |/ |/
â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  0  denominator      0  denominator
```

**Before:** Ratio explodes to infinity near zero

**After:** Ratio smoothly plateaus at a maximum value

<Lottie animation="adjustedGuard" height={220} width={320} caption="Guarding denominators prevents division by zero errors, ensuring ratios remain stable and predictable even with edge cases." />

---

## The Core Solution: Guard the Denominator ğŸ”’

Before dividing, always ask:

> "Is my denominator safe enough to divide by?"

**Basic pattern:**

```python
def safe_ratio(num, den, eps=1e-6):
    """
    Compute ratio with protection against small denominators
    
    Parameters:
    - num: numerator
    - den: denominator
    - eps: epsilon (small constant to replace near-zero denominators)
    
    Returns:
    - ratio: num / max(den, eps)
    """
    return num / np.where(np.abs(den) < eps, eps, den)
```

**How it works:**

1. Check if `|den| < eps`
2. If yes â†’ replace with `eps` (small constant)
3. If no â†’ use original `den`
4. Compute ratio normally

**Example:**

```python
num = 5
den = [10, 2, 0.5, 0.05, 0.001, 0]
eps = 1e-6

ratios = safe_ratio(num, den, eps)
# Result: [0.5, 2.5, 10.0, 100.0, 5e6, 5e6]
```

**Benefits:**

- âœ… No division by zero errors
- âœ… Smooth, continuous behavior
- âœ… Predictable maximum values
- âœ… Production-safe

---

## Why Use a Principled Epsilon? ğŸ“

**Problem with fixed epsilon:**

Setting `eps = 1e-6` or `1e-9` blindly can backfire:

```python
# Bad: Fixed epsilon
eps = 1e-6  # Too small for large-scale data
ratio = num / max(den, eps)

# If den values are in millions:
# den = 1,000,000 â†’ ratio works fine
# den = 0.000001 â†’ ratio = 5e6 (explodes!)
```

**Why it fails:**

- Arbitrary constant doesn't match data scale
- Too small â†’ still explodes
- Too large â†’ distorts real ratios
- Doesn't adapt to data distribution

**Solution: Data-driven epsilon**

Make **Îµ depend on your denominator's spread** using robust measures.

**Robust epsilon formula:**

```
Îµ = c Ã— MAD(denominator)
```

Where:
- **MAD** = Median Absolute Deviation (robust measure of scale)
- **c** = scaling factor (typically 0.1 to 0.5)

**Why MAD?**

- Robust to outliers (unlike standard deviation)
- Scale-invariant (adapts to data magnitude)
- Interpretable (median-based, not mean-based)

**Implementation:**

```python
def robust_epsilon(den, c=0.1):
    """
    Compute epsilon based on denominator's spread using MAD
    
    Parameters:
    - den: denominator values
    - c: scaling factor (default 0.1)
    
    Returns:
    - eps: data-driven epsilon
    """
    median_den = np.median(den)
    mad = np.median(np.abs(den - median_den))
    return c * mad

# Usage
denominator_data = [10, 2, 0.5, 0.05, 0.001, 0]
numerator_data = [5, 5, 5, 5, 5, 5]
eps = robust_epsilon(denominator_data, c=0.1)
ratio = safe_ratio(numerator_data, denominator_data, eps)
```

**Example calculation:**

```python
den = [10, 2, 0.5, 0.05, 0.001, 0]

# Step 1: Compute median
median = np.median(den)  # = 0.5

# Step 2: Compute MAD
deviations = np.abs(den - median)  # [9.5, 1.5, 0, 0.45, 0.499, 0.5]
mad = np.median(deviations)  # = 0.45

# Step 3: Compute epsilon
eps = 0.1 * mad  # = 0.045

# Step 4: Apply to ratios
ratios = safe_ratio(1, den, eps)
```

**Results:**

<table>
<thead>
<tr>
<th>Denominator</th>
<th>Clipped Den</th>
<th>Ratio (Num=1)</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>10</td>
<td>0.10</td>
<td>Normal</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0.50</td>
<td>Normal</td>
</tr>
<tr>
<td>0.5</td>
<td>0.5</td>
<td>2.00</td>
<td>Normal</td>
</tr>
<tr>
<td>0.05</td>
<td>0.045</td>
<td>22.22</td>
<td>Guarded</td>
</tr>
<tr>
<td>0.001</td>
<td>0.045</td>
<td>22.22</td>
<td>Guarded</td>
</tr>
<tr>
<td>0</td>
<td>0.045</td>
<td>22.22</td>
<td>Guarded</td>
</tr>
</tbody>
</table>


**Benefits:**

- âœ… Adapts to data scale automatically
- âœ… Robust to outliers
- âœ… Principled, not arbitrary
- âœ… Maintains relative relationships

<Lottie animation="robustWorkflow" height={220} width={320} caption="Using data-driven epsilon based on MAD ensures your ratio stabilization adapts to the actual scale of your data, not arbitrary constants." />

---

## Implementation: Complete Robust Ratio Function ğŸ”§

**Production-ready version:**

```python
import numpy as np
import pandas as pd

def robust_ratio(numerator, denominator, c=0.1, method='mad', 
                 clip_max=None, log_guards=False):
    """
    Compute robust ratio with data-driven epsilon
    
    Parameters:
    - numerator: array-like numerator values
    - denominator: array-like denominator values
    - c: scaling factor for epsilon (default 0.1)
    - method: method for computing epsilon ('mad' or 'iqr')
    - clip_max: maximum allowed ratio value (optional)
    - log_guards: if True, return count of guarded ratios
    
    Returns:
    - ratios: array of robust ratios
    - guard_count: number of ratios that were guarded (if log_guards=True)
    """
    num = np.asarray(numerator)
    den = np.asarray(denominator)
    
    # Compute epsilon based on method
    if method == 'mad':
        median_den = np.median(den)
        mad = np.median(np.abs(den - median_den))
        eps = c * mad
    elif method == 'iqr':
        q75, q25 = np.percentile(den, [75, 25])
        iqr = q75 - q25
        eps = c * iqr
    else:
        raise ValueError(f"Unknown method: {method}")
    
    # Handle zero epsilon (all denominators same)
    if eps == 0:
        eps = np.finfo(float).eps
    
    # Guard denominators
    den_safe = np.where(np.abs(den) < eps, eps, den)
    
    # Compute ratios
    ratios = num / den_safe
    
    # Clip if requested
    if clip_max is not None:
        ratios = np.clip(ratios, -clip_max, clip_max)
    
    # Count guards
    guard_count = np.sum(np.abs(den) < eps)
    
    if log_guards:
        return ratios, guard_count
    return ratios

# Example usage
numerator = np.array([10, 5, 2, 1, 0.5, 0.1])
denominator = np.array([100, 50, 10, 1, 0.01, 0])

ratios, guards = robust_ratio(numerator, denominator, c=0.1, log_guards=True)
print(f"Ratios: {ratios}")
print(f"Guarded ratios: {guards}/{len(denominator)}")
```

**Output:**

```
Ratios: [0.1, 0.1, 0.2, 1.0, 50.0, 10.0]
Guarded ratios: 2/6
```

---

## Advanced: Handling Signed Denominators ğŸ”„

**Problem:** Negative denominators can cause issues

**Solution:** Use absolute value for epsilon check, preserve sign

```python
def robust_ratio_signed(num, den, c=0.1):
    """
    Handle signed denominators correctly
    
    For negative denominators:
    - Check |den| < eps
    - If true, replace with sign(den) * eps
    """
    num = np.asarray(num)
    den = np.asarray(den)
    
    # Compute epsilon
    median_den = np.median(np.abs(den))
    mad = np.median(np.abs(np.abs(den) - median_den))
    eps = c * mad
    
    if eps == 0:
        eps = np.finfo(float).eps
    
    # Guard: preserve sign
    den_safe = np.where(
        np.abs(den) < eps,
        np.sign(den) * eps,  # Preserve sign
        den
    )
    
    return num / den_safe

# Example
num = [5, -5, 10]
den = [0.001, -0.001, 0.0001]

ratios = robust_ratio_signed(num, den, c=0.1)
# Result: [positive, negative, positive] - signs preserved!
```

---

## Real-World Application: Risk Scoring ğŸ’¼

**Scenario:** AML (Anti-Money Laundering) risk scoring

**Problem:**

```python
# Unsafe ratio
risk_score = transaction_amount / avg_account_balance

# Fails when:
# - New account (balance = 0)
# - Low-balance account (balance â‰ˆ 0)
# - Account closure (balance = 0)
```

**Solution:**

```python
def compute_risk_score(amount, avg_balance):
    """
    Compute robust risk score for AML monitoring
    """
    # Use robust ratio
    ratio = robust_ratio(
        amount, 
        avg_balance, 
        c=0.1,  # Conservative epsilon
        clip_max=1000  # Cap at 1000x
    )
    
    # Log guards for monitoring
    _, guard_count = robust_ratio(
        amount, 
        avg_balance, 
        c=0.1, 
        log_guards=True
    )
    
    if guard_count > 0:
        logger.warning(f"Guarded {guard_count} risk scores due to low balances")
    
    return ratio
```

**Benefits:**

- âœ… No crashes on zero balances
- âœ… Stable scores for low-balance accounts
- âœ… Monitoring and alerting built-in
- âœ… Production-ready

<Lottie animation="densityRadar" height={220} width={320} caption="Robust ratios act like a radar system, detecting and protecting against dangerous edge cases before they cause system failures." />

---

## Common Pitfalls âš ï¸

### 1. Epsilon Too Small ğŸš«

```python
# Bad: Too small
eps = 1e-9
ratio = num / max(den, eps)

# Problem: Still explodes for very small denominators
```

**Fix:** Use data-driven epsilon (MAD-based)

### 2. Epsilon Too Large ğŸš«

```python
# Bad: Too large
eps = 1.0
ratio = num / max(den, eps)

# Problem: Distorts real ratios even for normal denominators
```

**Fix:** Use small scaling factor (c = 0.1 to 0.5)

### 3. Ignoring Sign ğŸš«

```python
# Bad: Doesn't handle negative denominators
den_safe = np.where(den < eps, eps, den)

# Problem: Negative ratios become positive
```

**Fix:** Use `np.abs(den) < eps` and preserve sign

### 4. No Monitoring ğŸš«

```python
# Bad: No tracking
ratio = safe_ratio(num, den)

# Problem: Can't detect when guards are triggered frequently
```

**Fix:** Add logging and monitoring

### 5. Fixed Epsilon Across Features ğŸš«

```python
# Bad: Same epsilon for all features
eps = 1e-6
ratio1 = safe_ratio(num1, den1, eps)
ratio2 = safe_ratio(num2, den2, eps)

# Problem: Different features have different scales
```

**Fix:** Compute epsilon per feature

---

## When to Use Robust Ratios ğŸ¯

### Perfect For:

âœ… **Financial ratios**

```
ROE = net_income / equity
ROA = net_income / assets
Debt-to-equity = total_debt / equity
```

âœ… **Conversion metrics**

```
CTR = clicks / impressions
Conversion rate = conversions / visits
Bounce rate = bounces / sessions
```

âœ… **Growth rates**

```
YoY growth = (current - past) / past
MoM growth = (this_month - last_month) / last_month
```

âœ… **Efficiency metrics**

```
Revenue per employee = revenue / employees
Cost per acquisition = marketing_cost / acquisitions
```

### Don't Use When:

âŒ **Exact zero is meaningful**

```
If denominator = 0 means "not applicable"
â†’ Use NaN or separate flag, not ratio
```

âŒ **Very large denominators dominate**

```
If denominator >> numerator always
â†’ Consider log ratios or differences instead
```

âŒ **Ratios aren't the right metric**

```
If you need absolute differences
â†’ Use subtraction, not division
```

<Lottie animation="classicalVsRobust" height={220} width={320} caption="Robust ratios balance precision with stabilityâ€”choosing the right epsilon is like choosing between classical and robust methods." />

---

## Pro Tips ğŸ’¡

### 1. **Choose Scaling Factor Based on Use Case**

```python
# Conservative (financial)
eps = 0.05 * MAD(den)  # c = 0.05

# Moderate (general)
eps = 0.1 * MAD(den)   # c = 0.1

# Aggressive (exploratory)
eps = 0.5 * MAD(den)   # c = 0.5
```

### 2. **Monitor Guard Frequency**

```python
def robust_ratio_with_monitoring(num, den, c=0.1):
    ratios, guard_count = robust_ratio(num, den, c, log_guards=True)
    guard_pct = 100 * guard_count / len(den)
    
    if guard_pct > 10:  # More than 10% guarded
        logger.warning(f"High guard rate: {guard_pct:.1f}%")
    
    return ratios
```

### 3. **Use Different Methods for Different Distributions**

```python
# Normal-ish distribution
eps = 0.1 * MAD(den)

# Heavy-tailed distribution
eps = 0.1 * IQR(den)  # IQR more robust to outliers
```

### 4. **Clip Extreme Ratios**

```python
# Prevent infinite ratios
ratios = robust_ratio(num, den, c=0.1, clip_max=1000)
```

### 5. **Test Edge Cases**

```python
# Always test
test_cases = {
    'zeros': ([1, 2, 3], [0, 0, 0]),
    'near_zero': ([1, 2, 3], [1e-10, 1e-9, 1e-8]),
    'mixed': ([1, 2, 3], [10, 0.001, 0]),
    'negative': ([1, -1, 2], [0.001, -0.001, 0.01])
}

for name, (num, den) in test_cases.items():
    ratios = robust_ratio(num, den)
    print(f"{name}: {ratios}")
```

---

## The Mathematical Beauty ğŸ“

**Why MAD for epsilon?**

MAD is a robust measure of scale:

```
MAD = median(|x_i - median(x)|)
```

**Properties:**

- **Robust to outliers:** Unlike standard deviation
- **Scale-invariant:** Adapts to data magnitude
- **Interpretable:** Based on median, not mean
- **Efficient:** O(n log n) computation

<Lottie animation="breakdownFortress" height={220} width={320} caption="The mathematical foundation of robust ratios breaks down complex edge cases into manageable, stable computations." />

**Connection to other methods:**

- **IQR method:** Uses quartiles instead of median
- **Standard deviation:** Less robust but faster
- **Percentile method:** Uses specific percentiles

**Why c = 0.1?**

Empirical choice based on:
- Balance between stability and accuracy
- Works well across many domains
- Conservative enough to avoid distortion
- Aggressive enough to prevent explosions

---

## Summary Table ğŸ“‹

<table>
<thead>
<tr>
<th>Aspect</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Input</strong></td>
<td>Numerator and denominator arrays</td>
</tr>
<tr>
<td><strong>Method</strong></td>
<td>Guard denominators using data-driven epsilon</td>
</tr>
<tr>
<td><strong>Epsilon</strong></td>
<td>c Ã— MAD(denominator)</td>
</tr>
<tr>
<td><strong>Output</strong></td>
<td>Stable ratios without explosions</td>
</tr>
<tr>
<td><strong>Complexity</strong></td>
<td>O(n log n) for MAD computation</td>
</tr>
<tr>
<td><strong>Robustness</strong></td>
<td>High (uses median, not mean)</td>
</tr>
<tr>
<td><strong>Best for</strong></td>
<td>Ratios with variable denominators</td>
</tr>
<tr>
<td><strong>Avoid for</strong></td>
<td>Cases where zero is meaningful</td>
</tr>
</tbody>
</table>


---

## Final Thoughts ğŸŒŸ

**Robust ratios are production insurance** ğŸ›¡ï¸

- Ratios are powerful but need protection
- Division-by-zero isn't a math bugâ€”it's a data reality
- Robust guardrails make computations stable, continuous, and production-safe

**Your ratios should bend, not break.** ğŸ’ª

**Tomorrow's Preview:** Day 18 â€” Winsorization & Clipping for Stability! We'll learn how to cap extreme values while preserving distribution shape, perfect for handling outliers in features and targets. ğŸ“‰ğŸ¯

---

## Visualizations ğŸ“Š

<img src="/DS-17/ratio_map_comparison.png" alt="Ratio Stability Visualization" style={{maxWidth: '100%', height: 'auto', objectFit: 'contain', display: 'block', margin: '2rem auto'}} />
*Before: Ratio explodes to infinity near zero. After: Ratio smoothly plateaus at a maximum value, ensuring stable and predictable behavior.*

---

