<!DOCTYPE html>
<html>
<head>
    <title>DS-2 Visualizations Generator</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
        .chart-container { background: white; margin: 20px 0; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        h2 { color: #555; margin-top: 30px; }
        .instructions { background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <h1>ðŸ“Š DS-2 Visualizations Generator</h1>
    <div class="instructions">
        <strong>Instructions:</strong> Right-click on each canvas below and select "Save image as..." to save the visualizations.
        Make sure to save them in the public/DS-2 folder with the names: expression_pipeline.png, tokenization.png, precedence_ladder.png, infix_postfix.png, stack_evaluation.png, and worked_example_table.png
    </div>
    
    <h2>1. Expression Pipeline (Header Image)</h2>
    <div class="chart-container">
        <canvas id="expressionPipeline" width="1400" height="800"></canvas>
    </div>

    <h2>2. Tokenization Example</h2>
    <div class="chart-container">
        <canvas id="tokenization" width="1200" height="800"></canvas>
    </div>

    <h2>3. Precedence Ladder</h2>
    <div class="chart-container">
        <canvas id="precedenceLadder" width="1000" height="800"></canvas>
    </div>

    <h2>4. Infix to Postfix Conversion</h2>
    <div class="chart-container">
        <canvas id="infixPostfix" width="1200" height="1000"></canvas>
    </div>

    <h2>5. Stack-based Evaluation</h2>
    <div class="chart-container">
        <canvas id="stackEvaluation" width="1000" height="800"></canvas>
    </div>

    <h2>6. Worked Example Table</h2>
    <div class="chart-container">
        <canvas id="workedExample" width="900" height="600"></canvas>
    </div>

    <script>
        // Helper function to draw rounded rectangle
        function drawRoundedRect(ctx, x, y, width, height, radius, fillColor, strokeColor) {
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        // Helper function to draw arrow
        function drawArrow(ctx, x1, y1, x2, y2, color, lineWidth) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Arrow head
            const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 15 * Math.cos(angle - Math.PI/6), y2 - 15 * Math.sin(angle - Math.PI/6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 15 * Math.cos(angle + Math.PI/6), y2 - 15 * Math.sin(angle + Math.PI/6));
            ctx.fill();
        }

        // 1. Expression Pipeline
        function drawExpressionPipeline() {
            const canvas = document.getElementById('expressionPipeline');
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Title
            ctx.fillStyle = 'black';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Expression Evaluation Pipeline', canvas.width / 2, 80);
            
            const boxes = [
                {x: 150, y: 400, w: 180, h: 120, text: 'Expression String\n(score >= 0.85 and\nstability > 0.9)'},
                {x: 430, y: 400, w: 140, h: 120, text: 'Tokenize\nTokens'},
                {x: 680, y: 400, w: 160, h: 120, text: 'Respect\nPrecedence'},
                {x: 960, y: 400, w: 180, h: 120, text: 'Postfix (RPN)\nEvaluation'},
            ];
            
            boxes.forEach((box, i) => {
                drawRoundedRect(ctx, box.x, box.y - box.h/2, box.w, box.h, 10, 
                    i === 0 ? '#e3f2fd' : i === boxes.length - 1 ? '#c8e6c9' : '#fff3e0', 
                    '#1976d2');
                
                ctx.fillStyle = 'black';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                const lines = box.text.split('\n');
                lines.forEach((line, j) => {
                    ctx.fillText(line, box.x + box.w/2, box.y - box.h/2 + 35 + j * 25);
                });
                
                if (i < boxes.length - 1) {
                    drawArrow(ctx, box.x + box.w, box.y, boxes[i+1].x, box.y, 'black', 3);
                }
            });
        }
        
        // 2. Tokenization
        function drawTokenization() {
            const canvas = document.getElementById('tokenization');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Tokenization Example', canvas.width / 2, 60);
            
            const expression = '(score >= 0.85 and stability > 0.9) or (flag == 0)';
            ctx.font = 'italic 16px Arial';
            ctx.fillText('Input: ' + expression, canvas.width / 2, 100);
            
            const tokens = [
                {token: '(', type: 'Paren', color: '#bbdefb'},
                {token: 'score', type: 'ID', color: '#c8e6c9'},
                {token: '>=', type: 'Operator', color: '#fff9c4'},
                {token: '0.85', type: 'Number', color: '#ffccbc'},
                {token: 'and', type: 'Operator', color: '#e1bee7'},
                {token: 'stability', type: 'ID', color: '#c8e6c9'},
                {token: '>', type: 'Operator', color: '#fff9c4'},
                {token: '0.9', type: 'Number', color: '#ffccbc'},
                {token: ')', type: 'Paren', color: '#bbdefb'},
                {token: 'or', type: 'Operator', color: '#e1bee7'},
                {token: '(', type: 'Paren', color: '#bbdefb'},
                {token: 'flag', type: 'ID', color: '#c8e6c9'},
                {token: '==', type: 'Operator', color: '#fff9c4'},
                {token: '0', type: 'Number', color: '#ffccbc'},
                {token: ')', type: 'Paren', color: '#bbdefb'},
            ];
            
            let x = 120;
            let y = 200;
            const boxWidth = 70;
            const boxHeight = 50;
            const spacing = 80;
            
            tokens.forEach((t, i) => {
                if (i > 0 && i % 8 === 0) {
                    x = 120;
                    y += 120;
                }
                
                drawRoundedRect(ctx, x, y, boxWidth, boxHeight, 8, t.color, 'black');
                
                ctx.fillStyle = 'black';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(t.token, x + boxWidth/2, y + boxHeight/2 + 5);
                
                if (i < 5) {
                    ctx.fillStyle = 'gray';
                    ctx.font = 'italic 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(t.type, x + boxWidth/2, y + boxHeight + 15);
                }
                
                x += spacing;
            });
        }
        
        // 3. Precedence Ladder
        function drawPrecedenceLadder() {
            const canvas = document.getElementById('precedenceLadder');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Operator Precedence Ladder', canvas.width / 2, 60);
            
            const precedence = [
                {level: 1, name: 'Parentheses', symbols: '()'},
                {level: 2, name: 'Multiplication/Division', symbols: '* /'},
                {level: 3, name: 'Addition/Subtraction', symbols: '+ -'},
                {level: 4, name: 'Comparisons', symbols: '>= <= > < == !='},
                {level: 5, name: 'NOT (unary)', symbols: 'not'},
                {level: 6, name: 'AND', symbols: 'and'},
                {level: 7, name: 'OR', symbols: 'or'},
            ];
            
            const colors = ['#3f51b5', '#5c6bc0', '#7986cb', '#9fa8da', '#c5cae9', '#e8eaf6', '#f3e5f5'];
            
            precedence.forEach((item, i) => {
                const y = 150 + i * 90;
                const width = 700 - i * 50;
                const x = (canvas.width - width) / 2;
                
                const gradient = ctx.createLinearGradient(x, y - 30, x, y + 30);
                gradient.addColorStop(0, colors[i]);
                gradient.addColorStop(1, colors[i] + '80');
                
                drawRoundedRect(ctx, x, y - 30, width, 60, 5, gradient, 'black');
                
                ctx.fillStyle = 'black';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`${item.level}. ${item.name}: ${item.symbols}`, x + 20, y + 5);
                
                if (i < precedence.length - 1) {
                    drawArrow(ctx, x + width/2, y + 30, x + width/2, y + 50, 'gray', 2);
                }
            });
        }
        
        // 4. Infix to Postfix
        function drawInfixPostfix() {
            const canvas = document.getElementById('infixPostfix');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Infix â†’ Postfix (RPN) Conversion', canvas.width / 2, 60);
            
            // Infix section
            drawRoundedRect(ctx, 80, 150, canvas.width - 160, 180, 10, '#fff3e0', '#ff9800');
            
            ctx.fillStyle = 'black';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Infix Notation', canvas.width / 2, 220);
            
            ctx.font = 'bold 18px monospace';
            ctx.fillText('(score >= 0.85 and stability > 0.9) or (flag == 0)', canvas.width / 2, 270);
            
            ctx.font = 'italic 16px Arial';
            ctx.fillStyle = 'gray';
            ctx.fillText('Human-readable', canvas.width / 2, 300);
            
            // Arrow
            ctx.font = '48px Arial';
            ctx.fillStyle = 'gray';
            ctx.fillText('â†“', canvas.width / 2, 400);
            
            // Postfix section
            drawRoundedRect(ctx, 80, 450, canvas.width - 160, 180, 10, '#e8f5e9', '#4caf50');
            
            ctx.fillStyle = 'black';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Postfix (RPN) Notation', canvas.width / 2, 520);
            
            ctx.font = 'bold 18px monospace';
            ctx.fillStyle = '#2e7d32';
            ctx.fillText('score 0.85 >= stability 0.9 > and flag 0 == or', canvas.width / 2, 570);
            
            ctx.font = 'italic 16px Arial';
            ctx.fillStyle = 'gray';
            ctx.fillText('Machine-ready, unambiguous', canvas.width / 2, 600);
            
            // Evaluation steps
            ctx.fillStyle = 'black';
            ctx.font = 'bold 24px Arial';
            ctx.fillText('Stack-based Evaluation', canvas.width / 2, 720);
            
            const steps = [
                ['Read score â†’ Push 0.86', 'Read 0.85 â†’ Push 0.85', 'Read >= â†’ Pop 2, compare, push 1'],
                ['Read stability â†’ Push 0.91', 'Read 0.9 â†’ Push 0.9', 'Read > â†’ Pop 2, compare, push 1'],
                ['Read and â†’ Pop 2, apply min(1,1), push 1'],
                ['Read flag â†’ Push 1', 'Read 0 â†’ Push 0', 'Read == â†’ Pop 2, compare, push 0'],
                ['Read or â†’ Pop 2, apply max(1,0), push 1'],
                ['Result: 1 (True)']
            ];
            
            let yPos = 780;
            steps.forEach(step => {
                ctx.font = '14px Arial';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'left';
                ctx.fillText('â€¢ ' + step.join(' | '), 100, yPos);
                yPos += 30;
            });
        }
        
        // 5. Stack Evaluation
        function drawStackEvaluation() {
            const canvas = document.getElementById('stackEvaluation');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Stack-based Postfix Evaluation', canvas.width / 2, 60);
            
            const steps = [
                {name: 'Initial', stack: ['2', '3'], op: '+'},
                {name: 'Apply +', stack: ['5'], op: '5'},
                {name: 'Push 5', stack: ['5', '5'], op: '*'},
                {name: 'Apply *', stack: ['25'], op: ''},
            ];
            
            let yPos = 150;
            steps.forEach((step, i) => {
                ctx.fillStyle = 'black';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`${i+1}. ${step.name}:`, 80, yPos);
                
                let xPos = 350;
                step.stack.forEach((val, j) => {
                    const stackY = yPos - 40 - j * 35;
                    drawRoundedRect(ctx, xPos, stackY, 60, 30, 5, '#e3f2fd', 'navy');
                    ctx.fillStyle = 'black';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(val, xPos + 30, stackY + 19);
                });
                
                if (step.op) {
                    ctx.fillStyle = 'black';
                    ctx.font = '18px Arial';
                    ctx.fillText('â†’', xPos + 80, yPos - 25);
                    ctx.font = '20px Arial';
                    ctx.fillText(step.op, xPos + 130, yPos - 25);
                }
                
                yPos += 150;
            });
        }
        
        // 6. Worked Example Table
        function drawWorkedExample() {
            const canvas = document.getElementById('workedExample');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'black';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Worked Example: Full Evaluation', canvas.width / 2, 40);
            
            const headers = ['Row', 'score', 'stability', 'flag', 'Result', 'Explanation'];
            const data = [
                ['A', '0.86', '0.91', '1', 'True âœ“', '1 âˆ§ 1 âˆ¨ 0 = 1'],
                ['B', '0.86', '0.70', '0', 'True âœ“', '1 âˆ§ 0 âˆ¨ 1 = 1'],
                ['C', '0.70', '0.70', '1', 'False âœ—', '0 âˆ§ 0 âˆ¨ 0 = 0'],
            ];
            
            const colWidths = [80, 100, 120, 80, 120, 350];
            let xPos = 50;
            const headerY = 80;
            const rowHeight = 80;
            
            // Draw headers
            headers.forEach((header, i) => {
                drawRoundedRect(ctx, xPos, headerY - 30, colWidths[i], 60, 5, '#1976d2', 'black');
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(header, xPos + colWidths[i]/2, headerY);
                xPos += colWidths[i];
            });
            
            // Draw data rows
            data.forEach((row, i) => {
                xPos = 50;
                const rowY = 140 + i * rowHeight;
                
                row.forEach((cell, j) => {
                    const bgColor = j === 0 ? '#e3f2fd' : '#f5f5f5';
                    drawRoundedRect(ctx, xPos, rowY - 30, colWidths[j], 60, 5, bgColor, 'black');
                    ctx.fillStyle = 'black';
                    ctx.font = j === row.length - 1 ? '12px Arial' : '14px Arial';
                    ctx.textAlign = 'center';
                    const cellText = cell.length > 40 ? cell.substring(0, 38) + '...' : cell;
                    ctx.fillText(cellText, xPos + colWidths[j]/2, rowY);
                    xPos += colWidths[j];
                });
            });
        }
        
        // Run all drawings
        drawExpressionPipeline();
        drawTokenization();
        drawPrecedenceLadder();
        drawInfixPostfix();
        drawStackEvaluation();
        drawWorkedExample();
        
        console.log('All visualizations drawn! Right-click each canvas to save.');
    </script>
</body>
</html>

